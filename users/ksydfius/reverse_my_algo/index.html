<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Crackmes.de - Welcome to the longest running and most complete Crackmes web page on the internet.</title>
  <meta name="keywords" content="crackme, crackmes, reverseme, reversemes, keygenme, keygenmes, ethical hacking, cracking, reversing, reverse engineering, reverse code engineering, crack, hack, crackz, hackz">
  <meta name="description" content="Crackmes.de - Welcome to the longest running and most complete Crackmes web page on the internet.">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <link rel="stylesheet" href="/c2005080x.css" type="text/css" media="all" />
  <link rel="alternate" type="application/rss+xml" title="crackmes.de full RSS feed" href="/rss/" />
  <link rel="alternate" type="application/rss+xml" title="crackmes.de RSS feed without solutions" href="/rss-no-solutions/" />
  <script type="text/javascript" src="/fw.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-67455600-2', 'auto');
  ga('require', 'displayfeatures');
  ga('send', 'pageview');

</script>

</head>
<body>
      <div id="header"><table style="width:100%; border-collapse: collapse;"><tr><td style="margin: 0; padding: 0;"><a href="/" title="Crackmes.de"><img src="/img/logo.png" alt="crackmes.de" /></a></td>
      <td style="text-align: right;">


	</td>
      </tr></table></div>

      <ul id="mainmenu"><li><a href="/">Home</a></li><li><a href="/latest/">Latest</a></li><li><a href="/archive/">Search&nbsp;archive</a></li><li><a href="/submissions/">Your&nbsp;submissions</a></li><li><a href="/messages/">Messages</a></li><li><a href="/submit/">Submit&nbsp;your&nbsp;crackme</a></li>
  <li><a href="/faq/">FAQ</a></li><li style="clear:both;">&nbsp;</li></ul>
      <div id="sidebar">
      
    <div class="rmenu">
    <h2>Search for crackme</h2>
    <form id="qsearch" method="post" action="/">
    <input type="hidden" name="form_action" value="qsearch" />
    <input name="search_text" value="" />
    <button type="submit">search</button></form><br />
    <p style="margin: 0 0 0 5px;"><a href="/archive/">Advanced search &raquo;</a></p>
    </div><div class="rmenu">
    <h2>Recently discussed</h2><p style="margin-left: 5px; margin-top: 0;"><a href="/users/jim/lolcrackme1/" title="View discussion">Jim~: lolcrackme1</a><br /><br /><a href="/users/greedy_fly/keygenme_v1.8/" title="View discussion">Greedy_Fly: KeygenMe v1.8</a><br /><br /><a href="/users/greedy_fly/keygenme_v1.9/" title="View discussion">Greedy_Fly: KeygenMe v1.9</a><br /><br /><a href="/users/seveb/level_1/" title="View discussion">seVeb: Level 1</a><br /><br /><a href="/users/fr0gsek/fr0g_kgm1/" title="View discussion">fr0gsek: fr0g KGM#1</a><br /><br /><a href="/users/luxdav/luxxx_second_keygenme/" title="View discussion">luxdav: LuxXx' second keygenme</a><br /><br /><a href="/users/promix17/neweb/" title="View discussion">promix17: NEWEB</a><br /><br /></p></div><div class="rmenu"><h2>Various numbers</h2><ul id="stats"><li>Users: 140253</li><li>Crackmes: 2980</li><li>Solutions: 4155</li><li>9 crackmes in queue</li><li>22 solutions in queue</li><li>&nbsp;</li><li><a target="_blank" href="/gfx2.php" title="Submission statistics">World domination plan &raquo;</a></li></ul></div>
<div class="rmenu">
  <h2>Copyright information</h2>
  <p style="text-align:center; margin-right: 10px; font-size: 85%;margin-left: 3px;">All work presented here is presented under <br /><b>Creative Commons<br /> Attribution - Non Commercial</b> license unless specifically stated otherwise.</p>
  <p style="font-size: 90%;margin-left: 6px;"><a href="http://creativecommons.org/licenses/by-nc-nd/2.5/deed.en">License text in english &raquo;</a></p>
  <p style="font-size: 90%;margin-left: 6px;"><a href="http://creativecommons.org/licenses/by-nc-nd/2.5/deed.de">License text in german &raquo;</a></p>
  </div>      </div>

      <div class="content">
        <h1>

<!-- ID:3577 -->

<a href="/users/ksydfius/reverse_my_algo/download/ksydfius7.zip" title="Download, ksydfius7.zip, 1060 b"><img class="download" alt="download" src="/img/zip.gif" /></a><a href="/users/ksydfius/reverse_my_algo/browse" title="Browse contents"><img alt="browse" class="browse" src="/img/browse.gif" /></a><a title="View profile for ksydfius" href="/users/ksydfius">ksydfius</a>'s Reverse My Algo</h1><table style="width:99%"><tr><td><a style="margin-left:10px;" href="/users/ksydfius/reverse_my_algo/download/ksydfius7.zip"><strong>Download</strong> ksydfius7.zip, 1 kb</a> (password: <font color="red"><em>crackmes.de</em></font>)<br /><a style="margin-left:10px;" href="/users/ksydfius/reverse_my_algo/browse"><strong>Browse</strong> contents of ksydfius7.zip</a><p class="description">ASM crackme.<br />
<br />
Reverse the algo and find the pass :)<br />
<br />
Enjoy!<br />
<br />
-ksydfius</p><p>
<em class="ae">Difficulty:</em> 1 - Very easy, for newbies<br />
<em class="ae">Platform:</em> Windows<br />
<em class="ae">Language:</em> Assembler<br /><br />Published: 21. Nov, 2012<br />
Downloads: 850<br /></p></td><td style="width:200px;"><div style="border: 1px solid #666; background-color: #ddd; margin-bottom: 10px; "><h4 style="margin: 0; background-color: #666; color:#fff; border-bottom: 1px solid #000; padding: 2px; font-size: 11px;">Rating</h4><p style="margin: 3px;">Waiting for at least 3 votes<br />(we have only 2).<br /><br /><strong>Rate this crackme:</strong><br /><style type="text/css">
ul#votes, ul#votes li {
  padding: 0;
  margin-left: 20px;
}
ul#votes a {
  display: block;
  width: 100px;
  padding: 2px;
}
ul#votes a:hover {
  background-color: #666;
  color: #fff;
  font-weight: bold;
}
</style>
<ul id="votes"><li><a href="/users/ksydfius/reverse_my_algo/vote/1">boring crap</a></li><li><a href="/users/ksydfius/reverse_my_algo/vote/2">kinda boring</a></li><li><a href="/users/ksydfius/reverse_my_algo/vote/3">just ok</a></li><li><a href="/users/ksydfius/reverse_my_algo/vote/4">good</a></li><li><a href="/users/ksydfius/reverse_my_algo/vote/5">awesome</a></li></ul></p></div><a href="/messages?recipient=ksydfius">Send&nbsp;a&nbsp;message&nbsp;to&nbsp;ksydfius&nbsp;&raquo;</a><br /><br /><a href="/users/ksydfius">View profile of ksydfius &raquo;</a><br /></td></tr></table><h2>Solutions</h2><p style="margin-left:30px;">There are no solutions to this crackme yet.</p><p style="margin-left:30px;">The submission of solutions is closed.</p><h2>Discussion and comments</h2><table class="talk"><tr><th><strong><a title="View profile for mausy131" href="/users/mausy131">mausy131</a></strong><br />22. Nov 2012</th><td>Nice one. Working on it :)</td></tr><tr class="even"><th><strong><a title="View profile for terraNova" href="/users/terranova">terraNova</a></strong><br />23. Nov 2012</th><td>easy as told, but nice work!</td></tr><tr><th><strong><a title="View profile for lheer" href="/users/lheer">lheer</a></strong><br />26. Nov 2012</th><td>Good job<br />
That is correct!</td></tr><tr class="even"><th><strong><a title="View profile for audit" href="/users/audit">audit</a></strong><br />27. Nov 2012</th><td>That is correct!</td></tr><tr><th><strong><a title="View profile for Borgiman" href="/users/borgiman">Borgiman</a></strong><br />28. Nov 2012</th><td>I hope someone is writing a tut, i'm too dumb to solve this myself :P</td></tr><tr class="even"><th><strong><a title="View profile for Kempniu" href="/users/kempniu">Kempniu</a></strong><br />14. Dec 2012</th><td>Newbie here. Trying to solve this one, wrote a solver which generated a key that passes 3 of 4 checks and my last value only differs from the valid one by 1 bit (I get 5A74AC33 instead of 5A742C33). My suspicion is that I cannot simply reverse the RORs and XORs as the values in memory after the region checked by the crackme depend on the key provided, so I don't know what the memory contents for reversing are without the proper key. Any hints?</td></tr><tr><th><strong><a title="View profile for lemc" href="/users/lemc">lemc</a></strong><br />14. Dec 2012</th><td>I have solved this one by trial and error but by reversing the algo at: 00401028 and entering random data each time I noticed certain letters always wound up in the same spot after decryption.  I tried multiple phrases and finally got the solution.  I want to make my first ever tutorial for the community but dont know the sure shot method of getting the answer without trial and error.  Hopefully ksydfius or anyone else can help me a little since i did infact get the solution.  Thank you for the fun excersise ksydfius!</td></tr><tr class="even"><th><strong><a title="View profile for terraNova" href="/users/terranova">terraNova</a></strong><br />15. Dec 2012</th><td>Wrote a solution and submitted it (23. Nov), but it's still not checked by a moderator.</td></tr><tr><th><strong><a title="View profile for Fresco" href="/users/fresco">Fresco</a></strong><br />16. Dec 2012</th><td>i made the equivalent to c++;<br />
<br />
#include&lt;iostream&gt;<br />
#include&lt;stdlib.h&gt;<br />
#include&lt;fstream&gt;<br />
<br />
typedef unsigned char byte;<br />
using namespace std;<br />
<br />
unsigned char rotateright( unsigned char v, unsigned char x );<br />
unsigned int int_rotateright( unsigned int v, unsigned char x );<br />
void function_one(  );<br />
void function_two( int esi );<br />
void hex_dump(  );<br />
void data_dump(  );<br />
<br />
char start_arry[]={<br />
	0x64, 0x61, 0x74, 0x61, 0x2E, 0x74, 0x78, 0x74,<br />
	0x00, 0x47, 0x6F, 0x6F, 0x64, 0x20, 0x6A, 0x6F,<br />
	0x62, 0x00, 0x54, 0x68, 0x61, 0x74, 0x20, 0x69,<br />
	0x73, 0x20, 0x63, 0x6F, 0x72, 0x72, 0x65, 0x63,<br />
	0x74, 0x21, 0x00, 0x57, 0x68, 0x61, 0x74, 0x41,<br />
	0x72, 0x65, 0x59, 0x6F, 0x75, 0x44, 0x6F, 0x69,<br />
	0x6E, 0x67, 0x3F, 0x00, 0x54, 0x00, 0x00, 0x00,<br />
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,<br />
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,<br />
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,<br />
	0x00, 0x00, 0x00,<br />
};<br />
char *filename=start_arry, *wayd=start_arry+0x23, *data=start_arry+0x38;<br />
<br />
int main (){<br />
	ifstream data_txt( filename );<br />
	if( data_txt.good()==false ){<br />
		cout &lt;&lt; &quot;File does not exist!&quot;;<br />
		system(&quot;pause&quot;);<br />
		return 0;<br />
	}<br />
	data_txt.seekg(0, ios::beg);<br />
	data_txt.read(data, 0x10);<br />
    data_txt.close();<br />
    function_one();<br />
    function_two( 0x12 );<br />
    function_two( 0x23 );<br />
    function_two( 0x38 );<br />
    function_two( 0x23 );<br />
    function_two( 0x12 );<br />
    int *data_comparson = reinterpret_cast &lt;int*&gt;( start_arry+0x38 );<br />
    if( data_comparson[0]!=0xCD4558AD ){<br />
        cout &lt;&lt; &quot;Wrong code!&quot;;<br />
        system(&quot;pause&quot;);<br />
        return 0;<br />
    }<br />
    if( data_comparson[1]!=0xF7D5C9DB ){<br />
        cout &lt;&lt; &quot;Wrong code!&quot;;<br />
        system(&quot;pause&quot;);<br />
        return 0;<br />
    }<br />
    if( data_comparson[2]!=0x33C57B08 ){<br />
        cout &lt;&lt; &quot;Wrong code!&quot;;<br />
        system(&quot;pause&quot;);<br />
        return 0;<br />
    }<br />
    if( data_comparson[3]!=0x5A742C33 ){<br />
        cout &lt;&lt; &quot;Wrong code!&quot;;<br />
        system(&quot;pause&quot;);<br />
        return 0;<br />
    }<br />
    data_comparson = reinterpret_cast &lt;int*&gt;( start_arry+0x12 );<br />
    data_comparson[0]-=0x42ED41AE;<br />
    data_comparson[1]-=0xB6DFFEA1;<br />
    data_comparson[2]-=0xFA050ABE;<br />
    data_comparson[3]-=0x6B43746C;<br />
    cout &lt;&lt; &quot;Title = &quot; &lt;&lt; start_arry+0x9;<br />
    cout &lt;&lt; &quot;Body = &quot; &lt;&lt; start_arry+0x12;<br />
	system(&quot;pause&quot;);<br />
	return 0;<br />
}<br />
<br />
void function_one(  ){<br />
	int esi=0x23,<br />
		edi=0x38;<br />
	unsigned char al=1;<br />
    while( 1 ){<br />
		al=start_arry[esi];<br />
        if( al==0 ){<br />
        	break;<br />
        }<br />
        al = rotateright( al,3 );<br />
        start_arry[edi]=start_arry[edi] ^ al;<br />
        esi++;<br />
        edi++;<br />
	}<br />
    return;<br />
}<br />
<br />
void function_two( int esi ){<br />
	int eax=0,<br />
		ecx=0,<br />
        i=0;<br />
    int *int_arry = reinterpret_cast &lt;int*&gt;( start_arry+esi );<br />
    while( 1 ){<br />
		eax=int_arry[i];<br />
        if( eax==0 ){<br />
        	break;<br />
        }<br />
        eax=eax^0x7671295A;<br />
		ecx=eax;<br />
		ecx= int_rotateright( ecx,5 );<br />
		ecx=ecx+0xBADC0DED;<br />
		ecx= int_rotateright( ecx,5 );<br />
		int_arry[i]=ecx;<br />
		i++;<br />
	}<br />
    return;<br />
}<br />
<br />
unsigned char rotateright( unsigned char v, unsigned char x ){<br />
    int i=0;<br />
    loop:<br />
    if( i==x )<br />
        return v;<br />
    i++;<br />
	unsigned char temp = v &amp; 1;  // extract the low bit<br />
	v &gt;&gt;= 1;  // shift right<br />
	v |= ( temp&lt;&lt;7 ); // put the previous low bit in the high bit<br />
    goto loop;<br />
}<br />
<br />
unsigned int int_rotateright( unsigned int v, unsigned char x ){<br />
    int i=0;<br />
    loop:<br />
    if( i==x )<br />
        return v;<br />
    i++;<br />
	unsigned int temp = v &amp; 1;  // extract the low bit<br />
	v &gt;&gt;= 1;  // shift right<br />
	v |= ( temp&lt;&lt;31 ); // put the previous low bit in the high bit<br />
    goto loop;<br />
}</td></tr><tr class="even"><th><strong><a title="View profile for terraNova" href="/users/terranova">terraNova</a></strong><br />17. Dec 2012</th><td>http://pastebin.com/RiW5xbqk - Here is my solution if you guys are interested (Code to obtain the key and a quick description how i got there).</td></tr><tr><th><strong><a title="View profile for nekrobunny" href="/users/nekrobunny">nekrobunny</a></strong><br />17. Dec 2012</th><td>many keys that pass the check:<br />
<br />
20 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
24 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
25 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
26 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
27 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
41 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
42 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
43 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
4c 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
58 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
59 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
5a 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
5b 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
5d 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
5e 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
5f 7d 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
91 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
92 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
93 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
9c 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
a8 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
a9 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
aa 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
ab 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
ad 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
ae 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
af 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
b0 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
b4 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
b5 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
b6 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
b7 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 6<br />
b7 7e 66 61 6c dc 79 73 69 6b 25 ba 68 69 83 0d <br />
<br />
and many more...</td></tr><tr class="even"><th><strong><a title="View profile for lemc" href="/users/lemc">lemc</a></strong><br />20. Dec 2012</th><td>Nice work on the solutions!  When I solved it myself it was &quot;ureallylikethis&quot; (without quotes) in the data.txt file.</td></tr><tr><th><strong><a title="View profile for Fresco" href="/users/fresco">Fresco</a></strong><br />20. Dec 2012</th><td>yeah! it's really strange because my solution is: Seal\ysik%chis. and it works!<br />
<br />
#lemc How did you figure out &quot;ureallylikethis&quot; solution?<br />
 here's how i did mine:<br />
1) place a breakpoint before the checks.<br />
2) replace the generated bad code with the correct code (form the checks)<br />
3) the result should be something like the byte memory array in the decryption algo below;<br />
<br />
here's the c++ decryption algo:<br />
<br />
#include &lt;iostream&gt;<br />
#include &lt;stdlib.h&gt;<br />
#include &lt;fstream&gt;<br />
<br />
typedef unsigned char byte;<br />
using namespace std;<br />
<br />
byte memory[]={<br />
    0x64, 0x61, 0x74, 0x61, 0x2E, 0x74, 0x78, 0x74,<br />
    0x00, 0x47, 0x6F, 0x6F, 0x64, 0x20, 0x6A, 0x6F,<br />
    0x62, 0x00, 0x02, 0xAA, 0x4E, 0xB7, 0xC1, 0x67,<br />
    0x53, 0xD7, 0x21, 0x7A, 0x77, 0x6C, 0xD1, 0xD7,<br />
    0xB7, 0x8C, 0x40, 0x5E, 0xDA, 0x4A, 0xA9, 0x5E,<br />
    0x1E, 0x7A, 0x5B, 0x5A, 0x47, 0x0E, 0x0D, 0x7C,<br />
    0x57, 0xA2, 0xFF, 0x7A, 0x36, 0xC9, 0x96, 0x9E,<br />
    0xAD, 0x58, 0x45, 0xCD, 0xDB, 0xC9, 0xD5, 0xF7,<br />
    0x08, 0x7B, 0xC5, 0x33, 0x33, 0x2C, 0x74, 0x5A,<br />
    0x0B, 0x22, 0xD3, 0x63, 0xB7, 0x87, 0xB9, 0x7C,<br />
    0xF4, 0xCA, 0x00, 0x00, 0x00, 0x00<br />
};<br />
<br />
char* filename_char = reinterpret_cast &lt;char*&gt; ( memory+0x00 ),<br />
    * title_char = reinterpret_cast &lt;char*&gt; ( memory+0x09 ),<br />
    * text_char = reinterpret_cast &lt;char*&gt;( memory+0x12 ),<br />
    * data_char = reinterpret_cast &lt;char*&gt; ( memory+0x38 );<br />
byte* key_byte = reinterpret_cast &lt;byte*&gt; ( memory+0x23 ),<br />
    * data_byte = reinterpret_cast &lt;byte*&gt; ( memory+0x38 );<br />
int* text_int = reinterpret_cast &lt;int*&gt;( memory+0x12 ),<br />
   * data_int = reinterpret_cast &lt;int*&gt; ( memory+0x38 );<br />
<br />
byte ror8 ( byte x, byte times );<br />
byte rol8 ( byte x, byte times );<br />
unsigned int ror32 ( unsigned int x, byte times );<br />
unsigned int rol32 ( unsigned int x, byte times );<br />
<br />
void encryptstring();<br />
void data_calculation ( byte offset );<br />
void debug();<br />
<br />
int main (){<br />
    text_int[0]+=0x42ED41AE;<br />
    text_int[1]+=0xB6DFFEA1;<br />
    text_int[2]+=0xFA050ABE;<br />
    text_int[3]+=0x6B43746C;<br />
<br />
    data_calculation( 0x12 );<br />
    data_calculation( 0x23 );<br />
    data_calculation( 0x38 );<br />
    data_calculation( 0x23 );<br />
    data_calculation( 0x12 );<br />
    encryptstring();<br />
<br />
    ofstream data_txt( filename_char );<br />
	if( data_txt.good()==false ){<br />
		cout &lt;&lt; &quot;File: &quot; &lt;&lt; (char)0x22 &lt;&lt; filename_char &lt;&lt; (char)0x22 &lt;&lt; &quot; is used by another application&quot; &lt;&lt; endl;<br />
		system( &quot;pause&quot; );<br />
		return 0;<br />
	}<br />
	data_txt.seekp( 0, ios::beg );<br />
	data_txt.write( data_char, 0x10 );<br />
    data_txt.close();<br />
    cout &lt;&lt; &quot;Data was successfully written to: &quot; &lt;&lt; (char)0x22 &lt;&lt; filename_char &lt;&lt; (char)0x22 &lt;&lt; &quot;!&quot; &lt;&lt; endl;<br />
    cout &lt;&lt; &quot;In order to make algo work you have to copy the generated file: &quot; &lt;&lt; (char)0x22 &lt;&lt; filename_char &lt;&lt; (char)0x22 &lt;&lt; &quot; alongwith the executable itself.&quot; &lt;&lt; endl;<br />
    system( &quot;pause&quot; );<br />
    return 1;<br />
}<br />
<br />
void encryptstring(){<br />
    byte al=key_byte[0];<br />
    for( int i=0; al!=0; i++ ){<br />
        al = key_byte[i];<br />
        al = ror8( al,3 );<br />
        data_byte[i] ^= al;<br />
    }<br />
    return;<br />
}<br />
<br />
void data_calculation ( byte offset ){<br />
    int* raw_data = reinterpret_cast &lt;int*&gt; ( memory+offset );<br />
    for( int i=0; raw_data[i]!=0; i++ ){<br />
        raw_data[i] = rol32( raw_data[i],5 );<br />
        raw_data[i]-=0xBADC0DED;<br />
        raw_data[i] = rol32( raw_data[i],5 );<br />
        raw_data[i]^=0x7671295A;<br />
    }<br />
    return;<br />
}<br />
<br />
void debug(){<br />
    for( int i=0; i&lt;82; i++ ){<br />
        cout.width( 2 );<br />
        cout.fill( '0' );<br />
        if ( i%8==0 )<br />
            cout &lt;&lt; endl;<br />
        cout &lt;&lt; hex &lt;&lt; (int)memory[i] &lt;&lt; &quot; &quot;;<br />
    }<br />
    cout &lt;&lt; endl &lt;&lt; endl;<br />
    return;<br />
}<br />
<br />
byte ror8 ( byte x, byte times ){<br />
    byte temp=0;<br />
    for( byte i=0; i&lt;times; i++ ){<br />
	    temp = x&amp;0x01;<br />
	    x &gt;&gt;= 1;<br />
	    x |= ( temp&lt;&lt;7 );<br />
    }<br />
    return x;<br />
}<br />
<br />
byte rol8 ( byte x, byte times ){<br />
    byte temp=0;<br />
    for( byte i=0; i&lt;times; i++ ){<br />
     temp = x&amp;0x80;<br />
	    x &lt;&lt;= 1;<br />
	    x |= ( temp&gt;&gt;7 );<br />
    }<br />
    return x;<br />
}<br />
<br />
unsigned int ror32 ( unsigned int x, byte times ){<br />
    unsigned int temp=0;<br />
    for( byte i=0; i&lt;times; i++ ){<br />
	    temp = x&amp;0x00000001;<br />
	    x &gt;&gt;= 1;<br />
	    x |= ( temp&lt;&lt;31 );<br />
    }<br />
    return x;<br />
}<br />
<br />
unsigned int rol32 ( unsigned int x, byte times ){<br />
    unsigned int temp=0;<br />
    for( byte i=0; i&lt;times; i++ ){<br />
     temp = x&amp;0x80000000;<br />
	    x &lt;&lt;= 1;<br />
	    x |= ( temp&gt;&gt;31 );<br />
    }<br />
    return x;<br />
}</td></tr><tr class="even"><th><strong><a title="View profile for lemc" href="/users/lemc">lemc</a></strong><br />24. Dec 2012</th><td>#Fresco: Nice work on a c++ decrypter!  What I did to get my &quot;ureallylikethis&quot;solution was to first inline the reverse of the algo under the main code.  Then I tried 16 char long phrases such as the ones used in this program.  I tried the following (from what I can remember cause there were other phrases): &quot;is this correct?&quot;, &quot;imdoingasolution&quot; and &quot;thatsthesolution&quot;.  When the process finished the 16 chars of data that was left didn't work.  Now even though the return values didn't work they all had a similar pattern of recurring chars in sequence.  Such as &quot;ally&quot;, &quot;ike&quot; and &quot;his&quot;.  After trying a few words together I got &quot;ureallylikethis&quot; but realized it was only 15 chars long.  This is where luck comes in cause I wasn't going to try it but decided to for kicks and voila! It worked!  Hope this helped you understand how I got my solution.  If you really want I can remake my reverse algo solution in delphi + asm.  Thanks again to everyone who helped me understand this program more with your solutions!  And if you celebrate them, &quot;Happy Holidays&quot;!</td></tr><tr><th><strong><a title="View profile for [Wizzer]" href="/users/wizzer">[Wizzer]</a></strong><br />24. Dec 2012</th><td>Got stuck a bit, almost same issue as Kempniu, but 2 bytes difference. I made a reverse algo, so when I put the whole data array from Olly (for some known input) it goes right to left and decrypts correctly. Problem is that when I take that data array, replace &quot;key parts&quot; with correct values from comparison, I can't get a valid key. <br />
As example, data.txt file has text HelloPeople12345<br />
<br />
Before first comparison I see this result in Olly:<br />
<br />
0x64, 0x61, 0x74, 0x61, 0x2E, 0x74, 0x78, 0x74, 0x00, 0x47, 0x6F, 0x6F, 0x64, 0x20, 0x6A, 0x6F,<br />
0x62, 0x00, 0x02, 0xAA, 0x4E, 0xB7, 0xC1, 0x67, 0x53, 0xD7, 0x21, 0x7A, 0x77, 0x6C, 0xD1, 0xD7,<br />
0xB7, 0x8C, 0x40, 0x5E, 0xDA, 0x4A, 0xA9, 0x5E, 0x1E, 0x7A, 0x5B, 0x5A, 0x47, 0x0E, 0x0D, 0x7C,<br />
0x57, 0xA2, 0xFF, 0x41, 0x33, 0xC9, 0x0C, 0x6A, 0xCB, 0x98, 0x62, 0x84, 0x18, 0x8A, 0x96, 0x66,<br />
0x0E, 0x75, 0xF4, 0x73, 0x65, 0x4E, 0x74, 0x5A, 0xFF, 0x0E, 0xD3, 0x63, 0x97, 0x81, 0xB9, 0x7C,<br />
0x74, 0xD4, 0x00, 0x00, 0x00, 0x00<br />
<br />
(I added 0x myself and last 4 0x00)<br />
<br />
I decided to use Fresco's decrypter for testing, after running this I got file containing HelloPeople12345, so it is ok, now I will replace &quot;key&quot; location bytes with known values (from comparisons):<br />
<br />
0x64, 0x61, 0x74, 0x61, 0x2E, 0x74, 0x78, 0x74, <br />
	0x00, 0x47, 0x6F, 0x6F, 0x64, 0x20, 0x6A, 0x6F,<br />
	0x62, 0x00, 0x02, 0xAA, 0x4E, 0xB7, 0xC1, 0x67, <br />
	0x53, 0xD7, 0x21, 0x7A, 0x77, 0x6C, 0xD1, 0xD7,<br />
	0xB7, 0x8C, 0x40, 0x5E, 0xDA, 0x4A, 0xA9, 0x5E, <br />
	0x1E, 0x7A, 0x5B, 0x5A, 0x47, 0x0E, 0x0D, 0x7C,<br />
	0x57, 0xA2, 0xFF, 0x41, 0x33, 0xC9, 0x0C, 0x6A, <br />
	0xAD, 0x58, 0x45, 0xCD, 0xDB, 0xC9, 0xD5, 0xF7,<br />
	0x08, 0x7B, 0xC5, 0x33, 0x33, 0x2C, 0x74, 0x5A,<br />
	0xFF, 0x0E, 0xD3, 0x63, 0x97, 0x81, 0xB9, 0x7C,<br />
	0x74, 0xD4, 0x00, 0x00, 0x00, 0x00<br />
<br />
and now run the application again, it generates file, copy file, rerun app in Olly, breakpoint at first comparison, data is:<br />
<br />
64 61 74 61 2E 74 78 74 00 47 6F 6F 64 20 6A 6F<br />
62 00 02 AA 4E B7 C1 67 53 D7 21 7A 77 6C D1 D7<br />
B7 8C 40 5E DA 4A A9 5E 1E 7A 5B 5A 47 0E 0D 7C<br />
57 A2 FF 41 33 C9 0C 6A AD 58 45 CD DB CA D5 F7<br />
08 7B C5 33 33 2C 74 5A FF 0E D3 63 97 81 B9 7C<br />
74 D4<br />
<br />
and that key fails...<br />
<br />
What am I doing wrong? Could it be a byte at 0x34 affecting, the one that is hresult of CreateFileA (40107B)?<br />
<br />
(when I tried to decrypt data array that was in Fresco's sources - it worked, but can't get it working with my data)</td></tr><tr class="even"><th><strong><a title="View profile for lemc" href="/users/lemc">lemc</a></strong><br />25. Dec 2012</th><td>#Wizzer: That was my issue when I tried my own random data in the decryption routine I inlined.  It wouldn't work with the decrypted data I got.  I guess we just need to wait for ksydfius to post a working submitted solution or if not then hopefully a solution of his own so we can all understand the true decryption algo.  Either way I had fun with it and hope to see a 100% solution!</td></tr><tr><th><strong><a title="View profile for [Wizzer]" href="/users/wizzer">[Wizzer]</a></strong><br />25. Dec 2012</th><td>#lemc: Indeed, I've used a lot of efforts and no success, when I almost gave up and came here to see the solution, I was surprised that it was so &quot;simple&quot;, I felt like I missed some crucial part and everything went upside down, but when I tried to test use decryptor provided here I realized that it doesn't work either. Main difference are the bytes just before the key and right after, some do repeat, but around 8-10 of those are different (have to open logs to see for sure). Those effect decryption algo and when I &quot;inject&quot; values from comparison into data set generated from, for ex. HelloPeople12345, it comes to 1-2 (sometimes 3-4) bytes difference after decryption anyway.<br />
<br />
So I made a bruteforcer for my decrypting algo, I was substituting only bytes that differ depending on data.txt content - 6 of those in the tail (I didn't touch leading bytes, some differ there too), I was comparing 10 bytes after key location to be zeros after 5 passes of decryption, if all are - high chance that I got correct values, I tried it in a small range (in the tail, last 4 changing (not just last 4 bytes)) bytes for test) for a valid data set (the data set that was generated from data.txt, but key locations are not substituted). As soon as I tried the small range - brute found correct 4 last changing bytes.<br />
<br />
Bruteforcing to all changing bytes would take a long time... my assumption was author's original idea wasn't bruteforcing, cause of the range to brute, so I left that idea aside for now.<br />
<br />
P.S.: it is funny, but when I read your solution &quot;ureallylikethis&quot;, I could see letters that are part of it, so my own decrypting algo was trying to get exactly this key, when data.txt has default text, so input key was &quot;Greetings crackm&quot;, I took that data set, inject key parts from comparison, I ended up having:<br />
<br />
WreallysikeІhism<br />
0x57 0x72 0x65 0x61 0x6c 0x6c 0x79 0x73 0x69 0x6b 0x65 0xb2 0x68 0x69 0x73 0x6d 0x02 (!!!)<br />
<br />
as you can see, it looks very familiar, but doesn't work as input key (and actually it is 17 bytes long, trailing 0x02, remember that what I said that all bytes after keylocation+16 must be zeros? So this one is obviously a wrong key. It passes 3 of 4 checks and fails on last one:<br />
5A73AC33 compared to 5A742C33 - 2 bytes difference.<br />
<br />
Not let's take a look at a data set for that key:<br />
<br />
02 AA 4E B7 C1 67 53 D7 21 7A 77 6C D1 D7 B7 8C 40 5E DA 4A A9 5E 1E 7A 5B 5A 47 0E 0D 7C 57 A2 FF 42 33 C9 4F 66 AD 58 45 CD DB C9 D5 7 08 7B C5 33 33 AC 73 5A FB ED D3 63 77 6C B9 7C 34 D5<br />
<br />
And this is a data set for &quot;ureallylikethis&quot;:<br />
<br />
02 AA 4E B7 C1 67 53 D7 21 7A 77 6C D1 D7 B7 8C 40 5E DA 4A A9 5E 1E 7A 5B 5A 47 0E 0D 7C 57 A2 FF 40 33 C9 57 66 AD 58 45 CD DB C9 D5 F7 08 7B C5 33 33 2C 74 5A BB 23 D3 63 F7 73 B9 7C 74 D4<br />
<br />
10 bytes difference, including 2 bytes in key itself, now let me test my algo by feeding it latter dataset if I can get &quot;ureallylikethis&quot;... and I do get that 15 bytes length key, so algo does decrypt correctly:<br />
<br />
Thatiscorrect!WhatAreYouDoing?\ureallylikethis &lt;-- 0x00 were removed, but here is a decrypted dataset that provides accurate view:<br />
<br />
0x54 0x68 0x61 0x74 0x20 0x69 0x73 0x20 0x63 0x6f 0x72 0x72 0x65 0x63 0x74 0x21 0x00 0x57 0x68 0x61 0x74 0x41 0x72 0x65 0x59 0x6f 0x75 0x44 0x6f 0x69 0x6e 0x67 0x3f 0x00 0x5c 0x00 0x00 0x00 0x75 0x72 0x65 0x61 0x6c 0x6c 0x79 0x6c 0x69 0x6b 0x65 0x74 0x68 0x69 0x73 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00<br />
<br />
As I said 10 last bytes are zeros (11 here because key is 15 bytes)<br />
<br />
But I'm really looking forward a correct solution too :) According to IMHO (my lvl 1) point of view bruteforcing is required to get correct the key, that will make sure that last 10 bytes are zeros, 3 bytes before the key location are zeros and original texts (starting 403012) match, hresult byte 403034 can be ignored.<br />
<br />
That's all for now :)<br />
<br />
Thank you very much and happy holidays!</td></tr><tr class="evencolored"><th><strong><a title="View profile for ksydfius" href="/users/ksydfius">ksydfius</a></strong><br /><u>Author</u><br />30. Dec 2012</th><td>ok, here is my solution:<br />
<br />
unsigned long func1 (unsigned long l){<br />
	return rol(rol(l, 5) - 0xBADC0DED, 5) ^ 0x7671295A;<br />
}<br />
<br />
void func2 (unsigned char data[], char string1[], int len, int len_string1){<br />
	for (int n = 0; n &lt; len; n++){<br />
		unsigned char a = string1[n%len_string1];<br />
		a = ((a &lt;&lt; 5) | (a &gt;&gt; 3)) &amp; 0xFF;<br />
		data[n] ^= a;<br />
	}<br />
}<br />
<br />
void Decrypt (unsigned char data[], int len, int offset){<br />
	unsigned long dword;<br />
	for (int n = offset; n &lt; len; n+=4){<br />
		dword = (data[n+3] &lt;&lt; 24) | (data[n+2] &lt;&lt; 16) | (data[n+1] &lt;&lt; 8) | data[n];<br />
		dword = func1(dword);<br />
		data[n] = dword &amp; 0xFF; data[n+1] = (dword &amp; 0xFF00) &gt;&gt; 8;<br />
		data[n+2] = (dword &amp; 0xFF0000) &gt;&gt; 16; data[n+3] = (dword &amp; 0xFF000000) &gt;&gt; 24;<br />
	}<br />
}<br />
<br />
int main(){<br />
	unsigned char data[] = {0x02, 0xAA, 0x4E, 0xB7, 0xC1, 0x67, 0x53, 0xD7, 0x21, 0x7A, 0x77, 0x6C, 0xD1, 0xD7,	0xB7, 0x8C, <br />
							0x40, 0x5E, 0xDA, 0x4A, 0xA9, 0x5E, 0x1E, 0x7A, 0x5B, 0x5A, 0x47, 0x0E, 0x0D, 0x7C, 0x57, 0xA2, <br />
							0xFF, 0xA4, 0x34, 0xC9, 0x54, 0x66, 0xAD, 0x58, 0x45, 0xCD, 0xDB, 0xC9, 0xD5, 0xF7,	0x08, 0x7B, <br />
							0xC5, 0x33, 0x33, 0x2C, 0x74, 0x5A, 0xBB, 0x23, 0xD3, 0x63, 0xF7, 0x73, 0xB9, 0x7C, 0x74, 0xD4};<br />
	int len = 64;<br />
<br />
	char* string1 = &quot;WhatAreYouDoing?&quot;;<br />
<br />
	Decrypt(data, len, 0);<br />
	Decrypt(data, len, 0x11);<br />
	Decrypt(data, len, 0x26);<br />
	Decrypt(data, len, 0x11);<br />
	Decrypt(data, len, 0);<br />
<br />
	unsigned char enc[16];<br />
	for (int n = 0x26; n &lt; 0x26+16; n++) enc[n-0x26] = data[n];<br />
	<br />
	func2(enc, string1, 16, 16);<br />
	printf(&quot;%s\n&quot;, enc);<br />
<br />
	getch();<br />
}</td></tr><tr class="colored"><th><strong><a title="View profile for ksydfius" href="/users/ksydfius">ksydfius</a></strong><br /><u>Author</u><br />30. Dec 2012</th><td>answer: ireallylikethis</td></tr><tr class="even"><th><strong><a title="View profile for [Wizzer]" href="/users/wizzer">[Wizzer]</a></strong><br />02. Jan 2013</th><td>#ksydfius, thank you for your reply and Happy New Year :)<br />
<br />
I tried your source code with Fresco's rol32 function implementation, I can see &quot;ireallylikethis&quot; text output. My question is how did you get data[] byte content?<br />
<br />
What I did now:<br />
1)copy-pasted ReadMe.txt as data.txt file, edited, now file has &quot;Greetings crackm&quot; text inside, no quotes and yeah, editing wasn't necessary, so I see that file is 16 bytes now<br />
2)I run crackme in Olly, set breakpoint at first comparison at 4010F3 and binary copied 64 bytes starting at 403012 in memory dump<br />
3)I added 0x and commas in front of each<br />
4)pasted that data into your solution<br />
5)replaced 16 bytes in that data starting at 0x26 (key location) with bytes that are used in comparison: 0xAD, 0x58 ,0x45, 0xCD, 0xDB, 0xC9, 0xD5, 0xF7, 0x08, 0x7B, 0xC5, 0x33, 0x33, 0x2C, 0x74, 0x5A<br />
6)ran the application, btw I added to the end:<br />
        FILE* f = fopen(&quot;data.txt&quot;, &quot;wb&quot;);<br />
	fputs((char*)enc, f);<br />
	fclose(f);<br />
7)copy resulting data.txt to crackme's folder, run it in Olly with breakpoints set on first comparison<br />
8)3 of 4 checks pass, one fails with 2 bytes difference<br />
<br />
That is what I wrote about in my previous post, that my reverse algo gives some near solution answer too, but not the solution. I have a feeling that not every input can be reversed to a correct key or I'm still missing something :)<br />
<br />
Could you please comment on this? Thank you!</td></tr><tr class="colored"><th><strong><a title="View profile for ksydfius" href="/users/ksydfius">ksydfius</a></strong><br /><u>Author</u><br />02. Jan 2013</th><td>Wizzer,<br />
<br />
I think most of the bytes are constant, except for 2 or 3 that change depending on the input, so you will have to BF the bytes that change, then for each possibility decrypt the bytes<br />
The problem is the check routine is a bit loose, but you can narrow down the possibilities to find the correct one</td></tr><tr class="even"><th><strong><a title="View profile for [Wizzer]" href="/users/wizzer">[Wizzer]</a></strong><br />02. Jan 2013</th><td>#ksydfius, I feel like there are more bytes needed to be brute forced, in one of my posts I already wrote that I made a small bruteforcer, but saw that range to brute was big and gave up that idea, but seems I was correct, that bruteforcing might be required. Another way to brute could be to randomize input key and see if decryption succeeds, but that brings us to a condition that one needs to be lucky to get the correct input in the first place :)<br />
<br />
To summarize, I think:<br />
1)one has to be lucky with random input that would be correctly decrypted (byte difference will not affect key location)<br />
<br />
2)bruteforce bytes that are different to meet decryption requirements<br />
<br />
So, imho, second option is the correct solution to that crackme, though range (imho again) might be large (and probably also depends on initial input). If there was a constraint that key must be only a-zA-Z then bruteforcing seems to be even more of a correct (and the only?) solution :)<br />
<br />
But anyway, thank you for the challenge :)</td></tr><tr><th><strong><a title="View profile for lemc" href="/users/lemc">lemc</a></strong><br />05. Jan 2013</th><td>#ksydfius: Wow, I was co close with my solution lol.  Mine was &quot;ureallylikethis&quot; and your was &quot;ireallylikethis&quot;.  Thank you for posting your solution!</td></tr><tr class="even"><th><strong><a title="View profile for Fresco" href="/users/fresco">Fresco</a></strong><br />07. Jan 2013</th><td>for me, the solution can be everything that passes the check, it's just a guesswork :D but fun after all :D<br />
as for Wizzer ... here's how i got the arry:<br />
place some random string in the data.txt file and the place a breakpoint before the checks, ... just copy / pase the hex vals, use my algo, and it'll return a valid key ... obviously i couldn't know what the creator of the algo had in mind and i labeled vals with eax ebx etc and it's kinda confusing, but if you analyse it i's the same thing, the second one is better than the first one :D</td></tr><tr><th><strong><a title="View profile for Fresco" href="/users/fresco">Fresco</a></strong><br />08. Jan 2013</th><td>https://docs.google.com/folder/d/0B6cGfCmkO563S1NsTlVySUZVWlk/edit</td></tr><tr class="even"><th><strong><a title="View profile for [Wizzer]" href="/users/wizzer">[Wizzer]</a></strong><br />12. Jan 2013</th><td>#Fresco, still no luck for me :)<br />
<br />
0x64, 0x61, 0x74, 0x61, 0x2E, 0x74, 0x78, 0x74, <br />
0x00, 0x47, 0x6F, 0x6F, 0x64, 0x20, 0x6A, 0x6F,<br />
0x62, 0x00, 0x02, 0xAA, 0x4E, 0xB7, 0xC1, 0x67, <br />
0x53, 0xD7, 0x21, 0x7A, 0x77, 0x6C, 0xD1, 0xD7, <br />
0xB7, 0x8C, 0x40, 0x5E, 0xDA, 0x4A, 0xA9, 0x5E,<br />
0x1E, 0x7A, 0x5B, 0x5A, 0x47, 0x0E, 0x0D, 0x7C, <br />
0x57, 0xA2, 0xFF, 0x55, 0x33, 0xC9, 0x0C, 0x6A,<br />
0xCB, 0x98, 0x62, 0x84, 0x18, 0x8A, 0x96, 0x66, <br />
0x0E, 0x75, 0xF4, 0x73, 0x65, 0x4E, 0x74, 0x5A,<br />
0xFF, 0x0E, 0xD3, 0x63, 0x97, 0x81, 0xB9, 0x7C,<br />
0x74, 0xD4, 0x00, 0x00, 0x00, 0x00<br />
<br />
put that into your algo, you will get HelloPeople12345, what is correct, now let's replace in that array &quot;key&quot; location bytes with bytes from 4 cmps:<br />
<br />
 0x64, 0x61, 0x74, 0x61, 0x2E, 0x74, 0x78, 0x74, <br />
0x00, 0x47, 0x6F, 0x6F, 0x64, 0x20, 0x6A, 0x6F,<br />
0x62, 0x00, 0x02, 0xAA, 0x4E, 0xB7, 0xC1, 0x67, <br />
0x53, 0xD7, 0x21, 0x7A, 0x77, 0x6C, 0xD1, 0xD7, <br />
0xB7, 0x8C, 0x40, 0x5E, 0xDA, 0x4A, 0xA9, 0x5E,<br />
0x1E, 0x7A, 0x5B, 0x5A, 0x47, 0x0E, 0x0D, 0x7C, <br />
0x57, 0xA2, 0xFF, 0x55, 0x33, 0xC9, 0x0C, 0x6A,<br />
<br />
/*0xCB, 0x98, 0x62, 0x84, 0x18, 0x8A, 0x96, 0x66, <br />
0x0E, 0x75, 0xF4, 0x73, 0x65, 0x4E, 0x74, 0x5A, */<br />
<br />
0xAD, 0x58, 0x45, 0xCD, 0xDB, 0xC9, 0xD5, 0xF7,<br />
0x08, 0x7B, 0xC5, 0x33, 0x33, 0x2C, 0x74, 0x5A,<br />
<br />
0xFF, 0x0E, 0xD3, 0x63, 0x97, 0x81, 0xB9, 0x7C,<br />
0x74, 0xD4, 0x00, 0x00, 0x00, 0x00<br />
<br />
run, copy generated file, run crackme in olly, you will see that 3 of 4 checks pass, 1 fails with 1 byte difference (second check):<br />
F7D5C9DB compared to array's F7D5CADB</td></tr><tr><th><strong><a title="View profile for Fresco" href="/users/fresco">Fresco</a></strong><br />31. Jan 2013</th><td>yes, bruteforce may be necessary ;)</td></tr><tr class="even"><th><strong><a title="View profile for loizos" href="/users/loizos">loizos</a></strong><br />03. Mar 2013</th><td>Hey guys :P i got a question &gt;.&gt; How you reverse a program in C ??? I am actually using 'ollydbg' to reverse my staff.So please any1 help?</td></tr><tr><th><strong><a title="View profile for loizos" href="/users/loizos">loizos</a></strong><br />31. Mar 2013</th><td>Hello i learned how to reverse program am now can crack programs with difficulty level 3.This one was very easy.I 90 the jmp and past the serial key so easy :)</td></tr><tr class="even"><th><strong><a title="View profile for [Wizzer]" href="/users/wizzer">[Wizzer]</a></strong><br />08. Apr 2013</th><td>@loizos you missed the whole point here :) read the author's intro text again</td></tr><tr><th><strong><a title="View profile for Articstorm" href="/users/articstorm">Articstorm</a></strong><br />02. Jun 2013</th><td>is it normal that i cant open the *.exe file? it just terminates! :(</td></tr><tr class="even"><th><strong><a title="View profile for Shivajitheboss" href="/users/shivajitheboss">Shivajitheboss</a></strong><br />14. Oct 2015</th><td>I was able to patch it and get &quot;That is correct !&quot; message. But the problem I faced was the exe just wont start. Still working on it ;) Nice work bro.</td></tr></table><p style="margin-left:30px;">You may leave your comment, thoughts and discuss this crackme with other reversers here.<br />Acting childish will not be tolerated.<br />HTML and such will be left as-is, so don't try.</p><form style="margin-left:30px;" id="discussion" method="post" action="?">
  <input type="hidden" name="form_action" value="discussion_post" />
  <input type="hidden" name="crackme_id" value="3577" /><textarea cols="20" rows="20" style="width:350px; height: 100px;" name="message"></textarea><br /><button type="submit">Leave your comment</button></form>      </div>
      <br style="clear:both;" />
        
      <div id="footer">
        Moderators: 
       <a href="/users/andrewl.us">andrewl.us</a>, <a href="/users/black_eye">bLaCk-eye</a>, <a href="/users/cyclops">cyclops</a>, <a href="/users/numernia">Numernia</a>, <a href="/users/simonzack">simonzack</a>, <a href="/users/tamaroth">tamaroth</a>, <a href="/users/ZaiRoN">zairon</a>, <a href="/users/zero">Zero</a><br />
        Design and programming: <a target="_blank" href="http://elfz.laacz.lv">elfz</a><br />
        &copy; 1996-2014, Crackmes.de
<br/>
<span style="font-size: 9px;"><strong>Impressum</strong>: Angaben gemäß § 5 TMG: Dr. Thorsten Schneider, Lange Straße 31, 32051 Herford. Verantwortlicher im Sinne vom § 10 Abs. 3 MDStV: Dr. Thorsten Schneider, Lange Straße 31, 32051 Herford, Telefon: +49 (0) 5221 691 324. <strong>Kontakt</strong>: +49 5221 691 324. <strong>Hinweis: </strong>Diese Webseite inklusive aller enthaltenden Inhalte und Dateien entspricht einem "Internet Kunstwerk". <strong>Nutzungshinweis: </strong> Die gewerbliche Nutzung der auf dieser Webseite angebotenen Daten (einschließlich Bildmaterial) und Informationen ist nicht erlaubt und bedarf der ausdrücklichen schriftlichen Genehmigung. Die Nutzung der auf dieser Webseite angebotenen Daten (einschließlich Bildmaterial) und Informationen durch Rechtsanwälte, Juristen oder Rechtsanwaltkanzleien bzw. Sozietäten ist nicht erlaubt und bedarf der ausdrücklichen schriftlichen Genehmigung. <strong>Haftungsausschluss</strong>: <strong>Haftung für Inhalte: </strong>Nutzer dieser Webseite benutzen diese Webseite als auch deren Inhalte (Downloads etc.) auf eigene Gefahr. Der Betreiber übernimmt keine Haftung für Schäden jeglicher Art, beispielsweise durch Viren oder andere schadhafte Malware. Die Inhalte unserer Seiten wurden mit größter Sorgfalt erstellt. Für die Richtigkeit, Vollständigkeit und Aktualität der Inhalte können wir jedoch keine Gewähr übernehmen. Als Diensteanbieter sind wir gemäß § 7 Abs.1 TMG für eigene Inhalte auf diesen Seiten nach den allgemeinen Gesetzen verantwortlich. Nach §§ 8 bis 10 TMG sind wir als Diensteanbieter jedoch nicht verpflichtet, übermittelte oder gespeicherte fremde Informationen zu überwachen oder nach Umständen zu forschen, die auf eine rechtswidrige Tätigkeit hinweisen. Verpflichtungen zur Entfernung oder Sperrung der Nutzung von Informationen nach den allgemeinen Gesetzen bleiben hiervon unberührt. Eine diesbezügliche Haftung ist jedoch erst ab dem Zeitpunkt der Kenntnis einer konkreten Rechtsverletzung möglich. Bei Bekanntwerden von entsprechenden Rechtsverletzungen werden wir diese Inhalte umgehend entfernen. <strong>Haftung für Links: </strong>Unser Angebot enthält Links zu externen Webseiten Dritter, auf deren Inhalte wir keinen Einfluss haben. Deshalb können wir für diese fremden Inhalte auch keine Gewähr übernehmen. Für die Inhalte der verlinkten Seiten ist stets der jeweilige Anbieter oder Betreiber der Seiten verantwortlich. Die verlinkten Seiten wurden zum Zeitpunkt der Verlinkung auf mögliche Rechtsverstöße überprüft. Rechtswidrige Inhalte waren zum Zeitpunkt der Verlinkung nicht erkennbar. Eine permanente inhaltliche Kontrolle der verlinkten Seiten ist jedoch ohne konkrete Anhaltspunkte einer Rechtsverletzung nicht zumutbar. Bei Bekanntwerden von Rechtsverletzungen werden wir derartige Links umgehend entfernen. <strong>Urheberrecht: </strong>Die durch die Seitenbetreiber erstellten Inhalte und Werke auf diesen Seiten unterliegen dem deutschen Urheberrecht. Die Vervielfältigung, Bearbeitung, Verbreitung und jede Art der Verwertung außerhalb der Grenzen des Urheberrechtes bedürfen der schriftlichen Zustimmung des jeweiligen Autors bzw. Erstellers. Downloads und Kopien dieser Seite sind nur für den privaten, nicht kommerziellen Gebrauch gestattet. Soweit die Inhalte auf dieser Seite nicht vom Betreiber erstellt wurden, werden die Urheberrechte Dritter beachtet. Insbesondere werden Inhalte Dritter als solche gekennzeichnet. Sollten Sie trotzdem auf eine Urheberrechtsverletzung aufmerksam werden, bitten wir um einen entsprechenden Hinweis. Bei Bekanntwerden von Rechtsverletzungen werden wir derartige Inhalte umgehend entfernen. <strong>Datenschutz: </strong>Die Nutzung unserer Webseite ist in der Regel ohne Angabe personenbezogener Daten möglich. Soweit auf unseren Seiten personenbezogene Daten (beispielsweise Name, Anschrift oder eMail-Adressen) erhoben werden, erfolgt dies, soweit möglich, stets auf freiwilliger Basis. Diese Daten werden ohne Ihre ausdrückliche Zustimmung nicht an Dritte weitergegeben. Wir weisen darauf hin, dass die Datenübertragung im Internet (z.B. bei der Kommunikation per E-Mail) Sicherheitslücken aufweisen kann. Ein lückenloser Schutz der Daten vor dem Zugriff durch Dritte ist nicht möglich. Der Nutzung von im Rahmen der Impressumspflicht veröffentlichten Kontaktdaten durch Dritte zur Übersendung von nicht ausdrücklich angeforderter Werbung und Informationsmaterialien wird hiermit ausdrücklich widersprochen. Die Betreiber der Seiten behalten sich ausdrücklich rechtliche Schritte im Falle der unverlangten Zusendung von Werbeinformationen, etwa durch Spam-Mails, vor. Optimiert mit <a href="http://www.nanomites.com">nanomites</a>. Hilfe durch <a href="http://www.sethbricks.com/">Seth Bricks</a>.</span>


      </div>
    


</body>
</html>
